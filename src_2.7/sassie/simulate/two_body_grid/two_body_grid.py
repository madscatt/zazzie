'''    SASSIE: Copyright (C) 2011 Joseph E. Curtis, Ph.D.     This program is free software: you can redistribute it and/or modify    it under the terms of the GNU General Public License as published by    the Free Software Foundation, either version 3 of the License, or    (at your option) any later version.    This program is distributed in the hope that it will be useful,    but WITHOUT ANY WARRANTY; without even the implied warranty of    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the    GNU General Public License for more details.    You should have received a copy of the GNU General Public License    along with this program.  If not, see <http://www.gnu.org/licenses/>.'''import sysimport osimport stringimport numpyimport timeimport sasmol.sasmol as sasmolimport sassie.util.module_utilities as module_utilitiesimport sassie.util.sasconfig as sasconfigimport sassie.util.folder_management as folder_managementimport sassie.simulate.two_body_grid.poverlap as poverlapimport sassie.simulate.constraints.constraints as constraints#import pprint#import copy#    TWO-BODY GRID##    ADAPTED FROM GRID(IASE)##    12/15/09    --    initial coding                 :    jc#    12/16/09    --    hard coded for (integrase)        :    jc#    08/19/11    --    connected to gui                :    jc## LC     1         2         3         4         5         6         7# LC4567890123456789012345678901234567890123456789012345678901234567890123456789#                                                                      *      **'''        TWO-BODY GRID is the program to move a molecule on a grid.'''if sasconfig.__level__ == "DEBUG":    DEBUG = Trueapp = 'two_body_grid'class module_variables():    def __init__(self, parent=None):        self.app = appclass two_body_grid_input_variables():    def __init__(self, parent=None):        passclass two_body_grid():    def __init__(self, parent=None):        pass    def main(self, input_variables, txtOutput):        self.mvars = module_variables()        self.avars = two_body_grid_input_variables()        self.run_utils = module_utilities.run_utils(app, txtOutput)        self.run_utils.setup_logging(self)        self.log.debug('in main')        self.unpack_variables(input_variables)        self.run_utils.general_setup(self)        self.initialization()        self.two_body_grid()        self.epilogue()        return#   pgui performs this function#   def print_failure(message, txtOutput):##       txtOutput.put("\n\n>>>> RUN FAILURE <<<<\n")#       txtOutput.put(">>>> RUN FAILURE <<<<\n")#       txtOutput.put(">>>> RUN FAILURE <<<<\n\n")#       txtOutput.put(message)##       return    def unpack_variables(self,variables):        '''        method to extract variables into system wise class instance        '''        log = self.log        mvars = self.mvars        log.debug('in unpack_variables')            mvars.runname = variables['runname'][0]        mvars.path = variables['path'][0]        mvars.pdbmol1 = variables['pdbmol1'][0]        mvars.pdbmol2 = variables['pdbmol2'][0]        mvars.ofile = variables['ofile'][0]        mvars.accpos = variables['accpos'][0]        mvars.pos = variables['pos'][0]        mvars.trans = variables['trans'][0]        mvars.dtrans = variables['dtrans'][0]        mvars.theta = variables['theta'][0]        mvars.dtheta = variables['dtheta'][0]        mvars.basis = variables['basis'][0]        mvars.cutoff = variables['cutoff'][0]        mvars.lowrg = variables['lowrg'][0]        mvars.highrg = variables['highrg'][0]        mvars.zflag = variables['zflag'][0]        mvars.zcutoff = variables['zcutoff'][0]        mvars.cflag = variables['cflag'][0]        mvars.confile = variables['confile'][0]        mvars.nexsegments1 = variables['nexsegments1'][0]        mvars.nsegments1 = variables['nsegments1'][0]        mvars.reslow1 = variables['reslow1'][0]        mvars.numcont1 = variables['numcont1'][0]        mvars.nexsegments2 = variables['nexsegments2'][0]        mvars.nsegments2 = variables['nsegments2'][0]        mvars.reslow2 = variables['reslow2'][0]        mvars.numcont2 = variables['numcont2'][0]        log.debug(vars(mvars))                return#mvars:  runname, path, pdbmol1, pdbmol2, ofile, accpos, pos, trans, dtrans, theta, dtheta, basis, cutoff, lowrg, highrg, zflag, zcutoff, cflag, confile, nexsegments1, nsegments1, reslow1, numcont1, nexsegments2, nsegments2, reslow2, numcont2#avars: genpaths    def initialization(self):        '''        method to prepare for two_body_grid        '''        log = self.log        log.debug('in initialization')        pgui = self.run_utils.print_gui        mvars = self.mvars        avars = self.avars        if(mvars.runname[-1] == '/'):            lin = len(mvars.runname)            mvars.runname = mvars.runname[:lin - 1]        direxist = os.path.exists(mvars.runname)        if(direxist == 0):            os.system('mkdir -p ' + mvars.runname)        genpath = mvars.runname + '/two_body_grid'        avars.genpaths = genpath + '/'        direxist = os.path.exists(genpath)        if(direxist == 0):            os.system('mkdir -p ' + genpath)        log.debug(vars(mvars))        log.debug(vars(avars))        return            def report_status(self,this_trial, total_number_of_trials):        pgui = self.run_utils.print_gui                fraction_done = (float(this_trial) / float(total_number_of_trials))        report_string = 'STATUS\t' + str(fraction_done)        pgui(report_string)        return    def euler_rotation(self,m, phi, psi):          #not used?        mvars = self.mvars        c11 = numpy.cos(mvars.theta) * numpy.cos(psi)        c12 = numpy.cos(phi) * numpy.sin(psi) + numpy.sin(phi) * \            numpy.sin(mvars.theta) * numpy.cos(psi)        c13 = numpy.sin(phi) * numpy.sin(psi) - numpy.cos(phi) * \            numpy.sin(mvars.theta) * numpy.cos(psi)        c21 = -numpy.cos(mvars.theta) * numpy.sin(psi)        c22 = numpy.cos(phi) * numpy.cos(psi) - numpy.sin(phi) * \            numpy.sin(mvars.theta) * numpy.sin(psi)        c23 = numpy.sin(phi) * numpy.cos(psi) + numpy.cos(phi) * \            numpy.sin(mvars.theta) * numpy.sin(psi)        c31 = numpy.sin(mvars.theta)        c32 = -numpy.sin(phi) * numpy.cos(mvars.theta)        c33 = numpy.cos(phi) * numpy.cos(mvars.theta)        C = numpy.matrix([[c11, c12, c13], [c21, c22, c23], [c31, c32, c33]])        newcoor = numpy.array(m.coor()[0] * C)        m.setCoor(numpy.array([newcoor]))    def molgrid(self,m1, m2, m3, mask_array1, mask_array2, mask_a_array, mask_b_array, distance_array, type_array):        mvars = self.mvars        avars = self.avars        pgui = self.run_utils.print_gui        frame = 0        m1.calccom(frame)        com1 = m1.com()        m2.calccom(frame)        com2 = m2.com()        m3.calccom(frame)        com3 = m3.com()        mass1 = m1.mass()        totalmass1 = m1.totalmass()        mass2 = m1.mass()        totalmass2 = m2.totalmass()        mass3 = m3.mass()        totalmass3 = m3.totalmass()        temp_m3 = sasmol.SasMol(4)        error = temp_m3.merge_two_molecules(m1, m2)        pgui('total mass1 = %f' %(totalmass1))        pgui('total mass2 = %f' %(totalmass2))        pgui('total mass3 = %f' %(totalmass3))        totalmass12 = totalmass1 + totalmass2        pgui('mass 1 + mass 2 = %f' %(totalmass12))        numx = mvars.trans[0]        numy = mvars.trans[1]        numz = mvars.trans[2]        delx = mvars.dtrans[0]        dely = mvars.dtrans[1]        delz = mvars.dtrans[2]        if(mvars.accpos == 1):            lowx = mvars.pos[0]            lowy = mvars.pos[1]            lowz = mvars.pos[2]        else:            lowx = com2[0]            lowy = com2[1]            lowz = com2[2]        numthx = mvars.theta[0]        numthy = mvars.theta[1]        numthz = mvars.theta[2]        delthx = mvars.dtheta[0]        delthy = mvars.dtheta[1]        delthz = mvars.dtheta[2]        lowthx = 0.0        lowthy = 0.0        lowthz = 0.0        error, coor1 = m1.get_coor_using_mask(frame, mask_array1)        rm1 = sasmol.SasMol(3)        rm1.setCoor(coor1)        error, coor2 = m2.get_coor_using_mask(frame, mask_array2)        rm2 = sasmol.SasMol(4)        rm2.setCoor(coor2)        error = m1.copy_molecule_using_mask(rm1, mask_array1, frame)        error = m2.copy_molecule_using_mask(rm2, mask_array2, frame)        natoms1 = m1.natoms()        natoms2 = m2.natoms()        totalatoms = natoms1 + natoms2        coor = numpy.zeros((1, totalatoms, 3), numpy.float)        for i in range(natoms1):            coor[frame, i:] = m1.coor()[frame, i, :]        cartoutfile = avars.genpaths + 'gridrun_output.txt'        cartout = open(cartoutfile, 'w')        cartout.write(            "# COM positions and angular values FOR ACCEPTED STRUCTURES\n")        cartout.write("# x	y	z	thetax	thetay	thetaz\n")        rad2deg = 180.0 / numpy.pi        failtally = 0        ntrials = 0        cyclesum = 0.0        cycles = 0        start = time.time()  # TIME    Timing        taccepted = 0        dcdoutfile = m3.open_dcd_write(avars.genpaths + mvars.ofile)        total_number_of_trials = numx * numy * numz * numthx * numthy * numthz#        check dcd file size        temporary_dcdoutfile = m3.open_dcd_write('/tmp/temp.dcd')        m3.write_dcd_step(temporary_dcdoutfile, 0, 1)        file_size_mb = (os.path.getsize("/tmp/temp.dcd") /                    1048576.) * total_number_of_trials        file_size_gb = (os.path.getsize("/tmp/temp.dcd") /                    1073741824.) * total_number_of_trials        m3.close_dcd_write(temporary_dcdoutfile)        rmst = 'rm -f /tmp/temp.dcd'        os.system(rmst)        pgui('\nTOTAL NUMBER OF TRIALS = ' + str(total_number_of_trials))        pgui('\nMAXIUMUM FINAL DCD FILE SIZE (MB) = ' + str(file_size_mb))        pgui('MAXIUMUM FINAL DCD FILE SIZE (GB) = ' + str(file_size_gb))        pgui('\n\nSTARTING GRID MOVES\n\n')        for i in xrange(numx):            message = '\nstarting i = ' + str(i + 1) + ' of ' + str(numx)            pgui(message)             pgui('ntrials = ' + str(ntrials))            pgui('naccepted = ' + str(taccepted))            pgui('nfail = ' +str(failtally) + '\n')            if(ntrials > 0):                message = '\npercent acceptance = ' + str(((ntrials - failtally) / float(ntrials)) * 100.0) + '\n'                pgui(message)            tx = lowx + delx * i            for j in xrange(numy):                ty = lowy + dely * j                for k in xrange(numz):                    if(ntrials == 0):                        lasttime = start## OPEN    Timing of overlap functions#                    now = time.time()  # TIME    Timing                    cycles = cycles + 1                    cyclesum = cyclesum + (now - lasttime)                    # print "time = ",now-lasttime, ": avg = ",cyclesum/cycles                    lasttime = now                    tz = lowz + delz * k                    thxcount = 0                    thisthx = 0                    thisthy = 0                    thisthz = 0                    for angx in xrange(numthx):                        axis = 'x'                        if(thxcount == 0):                            mvars.theta = lowthx                            thxcount = 1                        else:                            mvars.theta = delthx                        thisthx = thisthx + mvars.theta                        m2.center(frame)                        m2.rotate(frame, axis, mvars.theta)                        m2.moveto(frame, [tx, ty, tz])                        thycount = 0                        for angy in xrange(numthy):                            axis = 'y'                            if(thycount == 0):                                mvars.theta = lowthy                                thycount = 1                            else:                                mvars.theta = delthy                            thisthy = thisthy + mvars.theta                            m2.center(frame)                            m2.rotate(frame, axis, mvars.theta)                            m2.moveto(frame, [tx, ty, tz])                            thzcount = 0                            for angz in xrange(numthz):                                ntrials = ntrials + 1                                check = 0                                axis = 'z'                                if(thzcount == 0):                                    mvars.theta = lowthz                                    thzcount = 1                                else:                                    mvars.theta = delthz                                thisthz = thisthz + mvars.theta                                m2.center(frame)                                m2.rotate(frame, axis, mvars.theta)                                m2.moveto(frame, [tx, ty, tz])                                self.report_status(                                    ntrials, total_number_of_trials)                                error, coor2 = m2.get_coor_using_mask(                                    frame, mask_array2)                                rm2.setCoor(coor2)                                check = poverlap.faboverlap(                                    rm1.coor(), rm2.coor(), mvars.cutoff)                                if(check == 0 and mvars.zflag == 1):                                    zee = rm2.coor()[0, :, 2]                                    zcheck = numpy.alltrue(                                        numpy.greater_equal(zee, mvars.zcutoff))                                    if(zcheck == 0):                                        check = 1                                if(check == 0):                                    for jj in range(natoms2):                                        coor[frame, jj + natoms1,                                            :] = m2.coor()[frame, jj, :]                                    temp_m3.setCoor(coor)                                    thisrg = temp_m3.calcrg(frame)                                    if(thisrg < mvars.highrg and thisrg > mvars.lowrg):                                        con_check = 0                                        if(mvars.cflag == 1):                                            con_check = constraints.check_constraints(                                                temp_m3, mask_a_array, mask_b_array, distance_array, type_array)                                        if(con_check == 0):                                            m3.setCoor(coor)                                            m3.write_dcd_step(                                                dcdoutfile, 0, taccepted + 1)                                            taccepted += 1                                            cartout.write("%f\t%f\t%f\t%f\t%f\t%f\n" % (                                                tx, ty, tz, thisthx * rad2deg, thisthy * rad2deg, thisthz * rad2deg))                                            cartout.flush()                                        else:                                            failtally = failtally + 1                                    else:                                        failtally = failtally + 1                                else:                                    failtally = failtally + 1        self.report_status(ntrials, total_number_of_trials)        time.sleep(1)#        print '\n\nFINAL STATS\n\n'#        print 'ntrials = ',ntrials#        print 'naccepted = ',taccepted#        print 'nfail = ',failtally        if(taccepted > 0):            pgui('\npercent acceptance = ' +                      str(((ntrials - failtally) / float(ntrials)) * 100.0))            pgui(                "\nConfigurations and statistics saved in %s directory\n\n" % ('./' + avars.genpaths))        else:            pgui('percent acceptance = ' +                      str(((ntrials - failtally) / float(ntrials)) * 100.0))            pgui(                "\n NO ACCEPTED MOVES\n\n Statistics saved in %s directory\n\n" % (avars.genpaths))        lineintxtOutput = ''.join(['=' for x in xrange(60)])        pgui("\n%s \n" % (lineintxtOutput))        time.sleep(1.0)        cartout.close()        m3.close_dcd_write(dcdoutfile)        return    def two_body_grid(self):        '''        TWO-BODY GRID is the program to move a molecule on a grid.            Molecule 1 is the reference molecule.        Molecule 2 is the molecule to be moved on the grid                     The molecules must have "residue" fields        INPUT:            run name        PDB file for molecule 1 (reference structure)        PDB file for molecule 2 (structure to be moved on the grid)        output DCD file name        accept supplied initial position for molecule 2 (0=no; use COM of molecule 2, 1=yes)        initial position of molecule 2 (x,y,z)        number of x,y,z moves (nx,ny,nz)        dx,dy,dz step sizes (Angstroms)        number of angular moves (nthetax,nthetay,nthetaz)        dtheta (dthetax,dthetay,dthetaz) step sizes (degress)        Advanced input:        overlap basis atom (only CA is accepted)        overlap cutoff distance        low Rg cutoff        high Rg cutoff        enable zcutoff flag (0=no, 1=yes)        zcutoff value (discard structures with any z-axis coordinates less than this value)        enable atomic constraint flag (0=no, 1=yes)        name of file describing additional constraints to check before accepting a structure        Excluded residue input:        number of segments in molecule 1 with residues excluded from overlap check                name of segments in molecule 1 with residues excluded from overlap check        first amino acid residue per segment (molecule 1)         number of contiguous amino acid residues per segment (molecule 1)        number of segments in molecule 2 with residues excluded from overlap check                name of segments in molecule 2 with residues excluded from overlap check        first amino acid residue per segment (molecule 2)         number of contiguous amino acid residues per segment (molecule 2)        OUTPUT:        original PDB files for molecule 1 and molecule 2        a DCD file with aligned coordinates        a reference PDB file for the DCD file        file containing x,y,z,thetax,thetay,thetaz coordinates of molecule 2        '''        log = self.log        mvars = self.mvars        avars = self.avars        pgui = self.run_utils.print_gui        log.debug('in two_body_grid')        m1 = sasmol.SasMol(0)        m2 = sasmol.SasMol(1)        m3 = sasmol.SasMol(2)        m1.read_pdb(mvars.pdbmol1)        m2.read_pdb(mvars.pdbmol2)        error = m3.merge_two_molecules(m1, m2)        if(error != []):            message = 'ERROR: ' + error[0]            pgui(message)        m3.write_pdb(avars.genpaths + mvars.ofile + '.pdb', 0, 'w')        cpst = 'cp ' + mvars.pdbmol1 + ' ' + avars.genpaths        os.system(cpst)        cpst = 'cp ' + mvars.pdbmol2 + ' ' + avars.genpaths        os.system(cpst)        frame = 0        mm1 = m1.calcminmax()        mm2 = m2.calcminmax()        lineintxtOutput = ''.join(['=' for x in xrange(60)])        ttxt = time.asctime(time.gmtime(time.time()))        pgui("\n%s \n" % (lineintxtOutput))        pgui("DATA FROM RUN: %s \n\n" % (ttxt))           log.debug('mm1 = ' + str(mm1))        log.debug('mm2 = ' + str(mm2))        # set overlap basis for each molecule        segment_names_1 = string.split(mvars.nsegments1, ',')        segment_names_2 = string.split(mvars.nsegments2, ',')        log.debug('segment_names_1 = '+ str(segment_names_1))        log.debug('segment_names_2 = '+ str(segment_names_2))        if(mvars.nexsegments1 > 0):            for i in xrange(mvars.nexsegments1):                if(i == 0):                    basis1st = "(name[i] == 'CA' and not (segname[i] == '" + segment_names_1[                        i] + "' and ( resid[i] >= " + str(mvars.reslow1[i]) + " and resid[i] <= " + str(mvars.reslow1[i] + mvars.numcont1[i]) + ")))"                else:                    basis1st = basis1st + " or (name[i] == 'CA' and not (segname[i] == '" + segment_names_1[                        i] + "' and ( resid[i] >= " + str(mvars.reslow1[i]) + " and resid[i] <= " + str(mvars.reslow1[i] + mvars.numcont1[i]) + " )))"        else:            basis1st = "name[i] == 'CA'"                log.debug('basis1st = ' + basis1st)        if(mvars.nexsegments2 > 0):            for i in xrange(mvars.nexsegments2):                if(i == 0):                    basis2st = "(name[i] == 'CA' and not (segname[i] == '" + segment_names_2[                        i] + "' and ( resid[i] >= " + str(mvars.reslow2[i]) + " and resid[i] <= " + str(mvars.reslow2[i] + mvars.numcont2[i]) + ")))"                else:                    basis2st = basis2st + " or (name[i] == 'CA' and not (segname[i] == '" + segment_names_2[                        i] + "' and ( resid[i] >= " + str(mvars.reslow2[i]) + " and resid[i] <= " + str(mvars.reslow2[i] + mvars.numcont2[i]) + " )))"        else:            basis2st = "name[i] == 'CA'"                log.debug('basis2st = ' + basis2st)                error, mask_array1 = m1.get_subset_mask(basis1st)        error, mask_array2 = m2.get_subset_mask(basis2st)        if(mvars.cflag == 1):            filter_flag = 0            error, constraint_basis1_array, constraint_basis2_array, distance_array, type_array = constraints.read_constraints(                m3, mvars.confile, filter_flag)            mask_a_array = []            mask_b_array = []            for i in xrange(len(distance_array)):                print constraint_basis1_array[i]                print constraint_basis2_array[i]                print distance_array[i]                print type_array[i]                error, local_mask_a_array = m3.get_subset_mask(                    constraint_basis1_array[i])                error, local_mask_b_array = m3.get_subset_mask(                    constraint_basis2_array[i])                mask_a_array.append(local_mask_a_array)                mask_b_array.append(local_mask_b_array)        else:            mask_a_array = []            mask_b_array = []            distance_array = []            type_array = []        self.molgrid(m1, m2, m3, mask_array1, mask_array2, mask_a_array, mask_b_array, distance_array, type_array)        return    def epilogue(self):        '''        method to print out results and to move results        to appropriate places.        '''        log = self.log        pgui = self.run_utils.print_gui        mvars = self.mvars        avars = self.avars        log.debug('in epilogue')          self.run_utils.clean_up(log)        lineintxtOutput = ''.join(['=' for x in xrange(60)])        pgui("\n%s \n" % (lineintxtOutput))        pgui('TWO BODY GRID IS DONE')        time.sleep(1.5)                      