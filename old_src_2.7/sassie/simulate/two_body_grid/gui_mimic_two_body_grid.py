'''Driver method to run the two-body grid module'''import sysimport stringimport osimport shutilimport timeimport sassie.interface.input_filter as input_filterimport sassie.simulate.two_body_grid.two_body_grid as two_body_grid#import two_body_grid as two_body_gridimport sassie.interface.two_body_grid.two_body_grid_filter as two_body_grid_filter#import two_body_grid_filter as two_body_grid_filterimport multiprocessingdef user_variables(self, **kwargs):    ### BEGIN USER EDIT ###    ### BEGIN USER EDIT ###    ### BEGIN USER EDIT ###    self.runname = 'run_0'    self.path='./'    self.pdbmol1='iase1.pdb'    self.pdbmol2='iase2.pdb'    self.ofile='run_0.dcd'    self.accpos='0'    self.pos='-20, -20, -20'    self.trans='2, 2, 2'    self.dtrans = '20,20,20'       self.theta = '2,2,2'           self.dtheta = '45,45,45'     self.basis = 'CA'    self.cutoff = '3.0'    self.lowrg = '0.0'    self.highrg = '400.0'    self.zflag = '0'    self.zcutoff = '-80.0'    self.cflag = '0'    self.confile = 'two_body_grid_constraints.txt'    self.nexsegments1 = '0'    self.nsegments1 = ''    self.reslow1 = ''    self.numcont1 = ''    self.nexsegments2 = '0'    self.nsegments2 = ''    self.reslow2 = ''    self.numcont2 = ''#    self.nexsegments1 = '3'#    self.nsegments1 = 'INT1, INT2, LED1'#    self.reslow1 = '271, 271, 94'#    self.numcont1 = '18, 18, 31'#    self.nexsegments2 = '3'#    self.nsegments2 = 'INT3, INT4, LED2'#    self.reslow2 = '271, 271, 94'#    self.numcont2 = '18, 18, 31'    self.testflag = False    ### END USER EDIT ###    ### END USER EDIT ###    ### END USER EDIT ###def test_variables(self, paths):    '''    users of gui_mimic as a driver script to run this module should not edit the values below as they    are used for development tests    this module defines variables that will be used to test the module as well as its input filter    variables are defined outside the class so that they can be used by these other programs    '''    pdb_data_path = paths['pdb_data_path']    dcd_data_path = paths['dcd_data_path']    other_data_path = paths['other_data_path']    module_data_path = paths['module_data_path']    self.runname = 'run_0'    self.path=''    self.pdbmol1=os.path.join(pdb_data_path,'iase1.pdb')    self.pdbmol2=os.path.join(pdb_data_path,'iase2.pdb')    self.ofile='run_0.dcd'    self.accpos='0'    self.pos='-20, -20, -20'    self.trans='2, 2, 2'    self.dtrans = '20,20,20'       self.theta = '2,2,2'           self.dtheta = '45,45,45'     self.basis = 'CA'    self.cutoff = '3.0'    self.lowrg = '0.0'    self.highrg = '400.0'    self.zflag = '0'    self.zcutoff = '0.0'    self.cflag = '0'    self.confile = os.path.join(other_data_path,'two_body_grid_constraints.txt')    self.nexsegments1 = '0'    self.nsegments1 = ''    self.reslow1 = ''    self.numcont1 = ''    self.nexsegments2 = '0'    self.nsegments2 = ''    self.reslow2 = ''    self.numcont2 = ''    self.precision = 3    self.testflag = True    def run_module(self, **kwargs):    '''    method to run the module and/or its input filter    only the module input filter is run if kwargs is: test_filter=True    method is defined outside the class so that it can be used     by other programs such as test_module and test_module_filter    '''    svariables = {}    svariables['runname'] = (self.runname, 'string')    svariables['path'] = (self.path, 'string')    svariables['pdbmol1'] = (self.pdbmol1, 'string')    svariables['pdbmol2'] = (self.pdbmol2, 'string')    svariables['accpos'] = (self.accpos,'int')    svariables['pos'] = (self.pos, 'float_array')    svariables['ofile'] = (self.ofile, 'string')    svariables['trans'] = (self.trans, 'int_array')    svariables['dtrans'] = (self.dtrans, 'float_array')    svariables['theta'] = (self.theta, 'int_array')    svariables['dtheta'] = (self.dtheta, 'float_array')        svariables['basis'] = (self.basis, 'string')    svariables['cutoff'] = (self.cutoff, 'float')    svariables['lowrg'] = (self.lowrg, 'float')    svariables['highrg'] = (self.highrg, 'float')    svariables['zflag'] = (self.zflag, 'int')    svariables['zcutoff'] = (self.zcutoff, 'float')    svariables['cflag'] = (self.cflag, 'int')    svariables['confile'] = (self.confile, 'string')    svariables['nexsegments1'] = (self.nexsegments1, 'int')    svariables['nsegments1'] = (self.nsegments1, 'string')    if self.nexsegments1 == '0':        svariables['reslow1'] = (self.reslow1, 'string')        svariables['numcont1'] = (self.numcont1, 'string')        else:        svariables['reslow1'] = (self.reslow1, 'int_array')        svariables['numcont1'] = (self.numcont1, 'int_array')    svariables['nexsegments2'] = (self.nexsegments2, 'int')    svariables['nsegments2'] = (self.nsegments2, 'string')    if self.nexsegments2 == '0':        svariables['reslow2'] = (self.reslow2, 'string')        svariables['numcont2'] = (self.numcont2, 'string')        else:        svariables['reslow2'] = (self.reslow2, 'int_array')        svariables['numcont2'] = (self.numcont2, 'int_array')    error, self.variables = input_filter.type_check_and_convert(svariables)#    print 'variables: ', self.variables    if len(error) > 0:        print 'error = ', error        if not(self.testflag):            sys.exit()        return error        try:        if kwargs['file_check']:            error = two_body_grid_filter.check_input_values(self.variables)    except:            error = two_body_grid_filter.check_input_values(self.variables, no_file_check="true")    print 'error: ', error    if len(error) > 0:        print 'error = ', error        if not(self.testflag):            sys.exit()        return error    try:        if kwargs['test_filter']:            return error    except:        pass    runname = self.variables['runname'][0]    if os.path.exists(os.path.join(runname, self.module)):        shutil.rmtree(os.path.join(runname, self.module))    txtQueue=multiprocessing.JoinableQueue()    this_two_body_grid = two_body_grid.two_body_grid()    this_two_body_grid.main(self.variables,txtQueue)class gui_mimic_two_body_grid():    '''    gui_mimic class contains the name of the module    '''    module = 'two_body_grid'    def __init__(self, test, paths):        if not test:            user_variables(self)        else:            test_variables(self, paths)        run_module(self)if __name__ == '__main__':    test = False  # option to run with test variables not implemented in 1.0.    paths = None# We are thinking of defining the install path so the gui mimic can be run from anywhere as long as it is called from that particular python# That way, the test files will always be available to the user.    if test:        pdb_data_path = os.path.join(os.path.dirname(os.path.realpath(            __file__)), '..', '..', 'data', 'pdb_common') + os.path.sep        dcd_data_path = os.path.join(os.path.dirname(os.path.realpath(            __file__)), '..', '..', 'data', 'dcd_common') + os.path.sep        other_data_path = os.path.join(os.path.dirname(os.path.realpath(            __file__)), '..', '..', 'data', 'other_common') + os.path.sep        module_data_path = os.path.join(os.path.dirname(os.path.realpath(            __file__)), '..', '..', 'data', 'simulate', 'energy_minimization') + os.path.sep        paths = {'pdb_data_path': pdb_data_path,                 'dcd_data_path': dcd_data_path, 'other_data_path': other_data_path, 'module_data_path': module_data_path}    start = time.time()    run_gui = gui_mimic_two_body_grid(test, paths)    print "time used: ", time.time() - start    