'''
    SASSIE: Copyright (C) 2011 Joseph E. Curtis, Ph.D. 

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
'''
import os
import sys
import shutil
import numpy
import multiprocessing

import sasmol.sasmol as sasmol
import sassie.analyze.apbs.gui_mimic_apbs as gui_mimic_apbs
#import gui_mimic_apbs as gui_mimic_apbs

import filecmp
from itertools import ifilter, izip
from unittest import main
from nose.tools import assert_equals
from mocker import Mocker, MockerTestCase

pdb_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'data', 'pdb_common') + os.path.sep
dcd_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'data', 'dcd_common') + os.path.sep
other_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'data', 'other_common') + os.path.sep
module_data_path = os.path.join(os.path.dirname(os.path.realpath(__file__)), '..', '..', 'data', 'analyze', 'apbs') + os.path.sep

paths = {'pdb_data_path' : pdb_data_path, 'dcd_data_path' : dcd_data_path, 'other_data_path' : other_data_path, 'module_data_path' : module_data_path}

class Test_apbs(MockerTestCase):

    '''
    System integration test for apbs.py / sassie 1.0

    APBS is the module that contains the functions
    that are used to run a series of electrostatic calculations
	on a set of structures in a supplied pdb/dcd file.

    INPUT:  variable descriptions:

            runname:        project name
            pdbfile:        reference pdb name
            infile:         input trajectory filename (pdb or dcd)
            ph:             pH value
            temperature:    temperature value (K)
            ion_conc:       concentration of solute ion (M)
            ion_radius:     radius of solute ion (angstroms)            


    OUTPUT:

            files stored in ~/runname/apbs directory:

            apbs_00001_io.mc            MC-shell I/O capture file   
            apbs_00001_pdb2pqr.dat      Output captured from PDB2PQR program
            apbs_00001_pot.dx.mc        File containing electrostatic potential information
            apbs_00001.in               Inputs for APBS calculation               
            apbs_00001.out              Output from APBS calculation                                    
            apbs_00001.pdb              PDB file with APBS outputs
            apbs_00001.pqr              PDB file generated by PDB2PQR program
            apbs_00001.propka           Output from protein PKA predictor program
            .
            .
            . 
            (depending on number of frames)

    Use cases:

    1.  Input trajectory file                       NOTE:  only two cases are tested since these tests take several minute per frame
        a.  input file is a single-frame PDB file
        b.  input file is a two-frame DCD file

    Inputs tested:

            runname:        project name
            pdbfile:        reference pdb name
            infile:         input trajectory filename (pdb or dcd)
            ph:             pH value
            temperature:    temperature value (K)
            ion_conc:       concentration of solute ion (M)
            ion_radius:     radius of solute ion (angstroms)            


    Test tree:

    project name

**************************
    input trajectory file 
**************************
    reference PDB           reference PDB           *reference PDB file
    input PDB               input DCD               *trajectory file

 
    '''

    module = 'apbs'

    def setUp(self):

       gui_mimic_apbs.test_variables(self, paths)


    def assert_list_almost_equal(self, a, b, places=5):
        if (len(a) != len(b)):
            raise TypeError
        else:
            for i in range(len(a)):
                if isinstance(a[i], (int, float, numpy.generic)):
                    if (numpy.isnan(a[i]) and numpy.isnan(b[i])):
                        continue
                    self.assertAlmostEqual(a[i], b[i], places)
                else:
                    self.assert_list_almost_equal(a[i], b[i], places)

    def check_dir_trees_equal(self,dir1, dir2):
        '''
        compares directories recursively as well as files within them
        excluding the files that contain timestamps (*io.mc, *.propka, *.out, *.sassie_json and *.sassie_log files)
        '''
        dirs_cmp = filecmp.dircmp(dir1, dir2, ['apbs_00001_io.mc', 'apbs_00001.propka', 'apbs_00001_pdb2pqr.dat',
                                               'apbs_00001.out', 'apbs_00002_io.mc', 'apbs_00002.propka', 'apbs_00002_pdb2pqr.dat', 'apbs_00002.out'])
#        if len(dirs_cmp.left_only)>0 or len(dirs_cmp.right_only)>0 or \
#            len(dirs_cmp.funny_files)>0:
        if len(dirs_cmp.right_only)>0 or len(dirs_cmp.funny_files)>0:
            return False
        (_, mismatch, errors) =  filecmp.cmpfiles(
            dir1, dir2, dirs_cmp.common_files, shallow=False)
        if len(mismatch)>0 or len(errors)>0:
            return False
        for common_dir in dirs_cmp.common_dirs:
            new_dir1 = os.path.join(dir1, common_dir)
            new_dir2 = os.path.join(dir2, common_dir)
            if not self.check_dir_trees_equal(new_dir1, new_dir2):
                return False
        return True

    def compare_files(self,file1,file2):

        def predicate(line):
            if 'Vacc_SASA' in line:
#           if line.startswith('Vacc_SASA'):       #another possibility
                return False # ignore it
            elif 'propka3.0' in line:
                return False
            elif 'Total time taken:' in line:
                return False
            elif 'Creation Date and Time' in line or 'Vnm_tstop' in line:
                return False
            return True

        with open(file1) as f1, open(file2) as f2:
            f1 = ifilter(predicate, f1)
            f2 = ifilter(predicate, f2)
            return(all(x == y for x, y in izip(f1, f2)))

    def test_1(self):
        '''
        test PDB input
        '''

        gui_mimic_apbs.run_module(self)

        ''' confirm output files are correct '''
        outdirectory = os.path.join(self.runname, self.module)
        print 'outdirectory: ', outdirectory
        correct_outdirectory = os.path.join(
            module_data_path, self.runname, self.module, 'pdb')
        print 'correct outdirectory: ', correct_outdirectory
        assert_equals(self.check_dir_trees_equal(outdirectory,correct_outdirectory), True)
        outfile = os.path.join(self.runname, self.module, 'apbs_00001.out')
        print 'outfile: ', outfile
        correct_outfile = os.path.join(module_data_path, self.runname, self.module, 'pdb', 'apbs_00001.out')
        print 'correct_outfile: ', correct_outfile
        assert_equals(self.compare_files(outfile,correct_outfile),True)
        outfile1 = os.path.join(self.runname, self.module, 'apbs_00001_io.mc')
        print 'outfile1: ', outfile1
        correct_outfile1 = os.path.join(module_data_path, self.runname, self.module, 'pdb', 'apbs_00001_io.mc')
        print 'correct_outfile1: ', correct_outfile1
        assert_equals(self.compare_files(outfile1,correct_outfile1),True)                       
        outfile2 = os.path.join(self.runname, self.module, 'apbs_00001_pdb2pqr.dat')
        print 'outfile2: ', outfile2
        correct_outfile2 = os.path.join(module_data_path, self.runname, self.module, 'pdb', 'apbs_00001_pdb2pqr.dat')
        print 'correct_outfile2: ', correct_outfile2
        assert_equals(self.compare_files(outfile2,correct_outfile2),True)
        outfile3 = os.path.join(self.runname, self.module, 'apbs_00001.propka')
        print 'outfile3: ', outfile3
        correct_outfile3 = os.path.join(module_data_path, self.runname, self.module, 'pdb', 'apbs_00001.propka')
        print 'correct_outfile3: ', correct_outfile3
        assert_equals(self.compare_files(outfile3,correct_outfile3),True)                       

                       
    def test_2(self):
        '''
        test DCD input
        '''
        self.infile = os.path.join(dcd_data_path,'ten_mer_two_frames.dcd')
        gui_mimic_apbs.run_module(self)

        ''' confirm output files are correct '''
        outdirectory = os.path.join(self.runname, self.module)
        print 'outdirectory: ', outdirectory
        correct_outdirectory = os.path.join(
            module_data_path, self.runname, self.module, 'dcd')
        print 'correct outdirectory: ', correct_outdirectory
        assert_equals(self.check_dir_trees_equal(outdirectory,correct_outdirectory), True)
        outfile = os.path.join(self.runname, self.module, 'apbs_00001.out')
        print 'outfile: ', outfile
        correct_outfile = os.path.join(module_data_path, self.runname, self.module, 'dcd', 'apbs_00001.out')
        print 'correct_outfile: ', correct_outfile
        assert_equals(self.compare_files(outfile,correct_outfile),True)
        outfile1 = os.path.join(self.runname, self.module, 'apbs_00001_io.mc')
        print 'outfile1: ', outfile1
        correct_outfile1 = os.path.join(module_data_path, self.runname, self.module, 'dcd', 'apbs_00001_io.mc')
        print 'correct_outfile1: ', correct_outfile1
        assert_equals(self.compare_files(outfile1,correct_outfile1),True)                       
        outfile2 = os.path.join(self.runname, self.module, 'apbs_00001_pdb2pqr.dat')
        print 'outfile2: ', outfile2
        correct_outfile2 = os.path.join(module_data_path, self.runname, self.module, 'dcd', 'apbs_00001_pdb2pqr.dat')
        print 'correct_outfile2: ', correct_outfile2
        assert_equals(self.compare_files(outfile2,correct_outfile2),True)
        outfile3 = os.path.join(self.runname, self.module, 'apbs_00001.propka')
        print 'outfile3: ', outfile3
        correct_outfile3 = os.path.join(module_data_path, self.runname, self.module, 'dcd', 'apbs_00001.propka')
        print 'correct_outfile3: ', correct_outfile3
        assert_equals(self.compare_files(outfile3,correct_outfile3),True)                       
        outfile4 = os.path.join(self.runname, self.module, 'apbs_00002.out')
        print 'outfile4: ', outfile4
        correct_outfile4 = os.path.join(module_data_path, self.runname, self.module, 'dcd', 'apbs_00002.out')
        print 'correct_outfile4: ', correct_outfile4
        assert_equals(self.compare_files(outfile4,correct_outfile4),True)
        outfile5 = os.path.join(self.runname, self.module, 'apbs_00002_io.mc')
        print 'outfile5: ', outfile5
        correct_outfile5 = os.path.join(module_data_path, self.runname, self.module, 'dcd', 'apbs_00002_io.mc')
        print 'correct_outfile5: ', correct_outfile5
        assert_equals(self.compare_files(outfile5,correct_outfile5),True)                       
        outfile6 = os.path.join(self.runname, self.module, 'apbs_00002_pdb2pqr.dat')
        print 'outfile6: ', outfile6
        correct_outfile6 = os.path.join(module_data_path, self.runname, self.module, 'dcd', 'apbs_00002_pdb2pqr.dat')
        print 'correct_outfile6: ', correct_outfile6
        assert_equals(self.compare_files(outfile6,correct_outfile6),True)
        outfile7 = os.path.join(self.runname, self.module, 'apbs_00002.propka')
        print 'outfile7: ', outfile7
        correct_outfile7 = os.path.join(module_data_path, self.runname, self.module, 'dcd', 'apbs_00002.propka')
        print 'correct_outfile7: ', correct_outfile7
        assert_equals(self.compare_files(outfile7,correct_outfile7),True)                       

    def tearDown(self):
        if os.path.exists(self.runname):
            shutil.rmtree(self.runname)


if __name__=='__main__':
    main()

